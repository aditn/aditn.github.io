{
  "name": "Surface Reconstruction for 3D Point Cloud in Parallel",
  "tagline": "Adit Namdev and Jordan Tick",
  "body": "## Project Proposal\r\n### Summary\r\nWe are going to generate and optimize a 3D triangle mesh for point clouds. If we have enough time, our reach goal would be generating the point clouds will be generated using a Xbox Kinect. The computation will be done on an NVIDIA GPU.\r\n\r\n### Background\r\nComputer graphics revolves around the central concept of meshes. These essentially graph-like structures allow for computation to be highly parallel because usually you want to do an operation over all vertices or all edges, etc. Our goal is to generate a mesh based off a list of vertices. To do this, we must first find the nearby ‘neighborhood’ for each vertex and then connect these nearby points together in a coherent, geometrically sound way. This idea of geometrically sound is more formally known as “manifold”. A manifold mesh is essentially a mesh that doesn’t have any holes in it, no internal faces, and no overlapping edges or parts of the mesh with zero area (a popular example of this error is two pyramids connected at a single point to form an ‘hourglass’). More simply, another definition is that every edge only has a max of two faces (aka triangles) coming off of it. Once we have created a mesh, we must then try to make it optimal! This was essentially the first homework for 15-462 with three operations: 1) subdivision, 2) edge flipping, and 3) edge collapsing. What the goal of these operations are is essentially to smooth out your graph and minimize how many vertices are connected together. Subdivision breaks up a vertex into multiple vertices (finer mesh = smoother), edge flipping can result in fewer connections between certain vertices, and edge collapsing can collapse multiple triangles together (you only need two triangles to represent a plane, no more!).\r\n\r\nSo what was described above is how to connect vertices based on nearest neighbor search and then improve the quality of your mesh based on a few atomic operations. This works if our point cloud is well defined. If we get to our reach goal of using the connect though, it is possible we may deal with bad point clouds! This idea of a ‘noisy’ mesh could be combatted by A) threshold how far away the nearest neighbor can be to detect ‘outlier’ points and B) use the aforementioned algorithm to smooth out bumpy surfaces by downsampling and then upsampling. That’s the rough idea of our approach! It is nicely segmented into three steps: 1) creation of mesh, 2) improvement of mesh, and 3) using kinect to generate a point cloud. How optimal #1 is determines how long #2 takes. Doing #1 in parallel requires a lot of communication between processes (imagine creating separate meshes and ‘gluing’ them together at their edges. Algorithms like nearest neighbor and noise reduction are highly parallelizable whereas connecting connecting vertices via edges is highly serial (although we could create multiple meshes and ‘glue’ them together at the end as previously stated.\r\n\r\n### The Challenge\r\nThere are a couple issues for this project. The first difficulty is with regards to memory. GPUs do not have a large amount of space, thus most of the data needs to be in DRAM (especially for large point clouds). The second and more difficult problem is generating partial meshes on different cores and combining them after computation. These two challenges go hand in hand, particularly if the initial point cloud is very large and we cannot completely compute all the sections of the point cloud in one go. We hope to learn how to deal with the memory constraint and improve performance (via load balancing) while keeping correctness.\r\n\r\n### Resources\r\nCode: C++, Cuda, PCL libraries (optional: for point cloud generation and visualization)\r\n\r\nHardware: Microsoft Kinect (for capturing point clouds), Nvidia GPU (might be able to use the GHC servers)\r\n\r\nWe are planning on doing a triangle mesh. We will be doing more research on this, but Delaunay Triangulation is an option we are thinking about based on an initial search.\r\n\r\n^ We will ideally find a paper for a rough outline of how to make sure we build a valid mesh.\r\n\r\n^^ We would need access to a kinect as we do not have one ourselves. \r\n\r\n### Goals and Deliverables\r\nThe nice thing about our project is that it is implemented in steps. Step 1 is to find a way to display points and triangles on our screen (seeing as these are all solid figures, a simple rasterizer could either be found online or written based on old 15462 code). Step 2 is to generate the mesh based on a list of vertices (we expect this step to take the most time). Step 3 is improve the mesh using the operations described in background (Jordan has implemented these before and says they are highly parallelizable so this step should be easy). Step 4 is using a point cloud based off kinect. Before this step, we will just download obj meshes off the internet and delete their edges so that we are working with ideal meshes. Working with a point cloud shouldn’t be too much harder, it just might require correcting for error. Thus our milestones are these:\r\n\r\n* Milestone 1: visualize our points and triangles.\r\n* Milestone 2: create a mesh based off a list of vertices.\r\n* Milestone 3 (and checkpoint!): create this mesh in parallel\r\n* Milestone 4: optimize mesh in parallel\r\n* Milestone 5: use kinect to get point clouds\r\n* Milestone 6 (and end of project!): Use kinect to create a 3D mesh of a scene.\r\n\r\nBasically, step 1 and 4 are the easy GUI steps, steps 2 and 3 are where the majority of the project will be, and steps 5 and 6 are cool things to visualize our project with if we have time.\r\n\r\n### Platform Choice\r\nPCL is a very good library for point clouds and is already implemented in C++. We are very familiar with C++ and Cuda which will make our development speed faster. Microsoft Kinect is a great resource for capturing point clouds at medium distances. If we want to capture close range point clouds, we may want to choose a different depth camera (such as DepthSense from SoftKinectic). \r\n\r\n### Schedule\r\n* Week 1 (By Nov 7): Visualize our points and triangles and research algorithms for creating mesh.\r\n* Week 2 (By Nov 14): Create a mesh based off a list of vertices.\r\n* Week 3 (By Nov 21): Work on creating this mesh in parallel.\r\n* Week 4 (By Nov 28): Finish creating mesh in parallel. Begin parallelizing the optimization step.\r\n* Week 5 (By Dec 5): Finish parallelizing optimization. Use kinect to get point clouds.\r\n* Week 6 (By Dec 13): Use kinect to create a 3D mesh of a scene.\r\n\r\n\r\n\r\n### Updated Schedule\r\nWe are roughly on track. We are debugging our serial implementation this week, and then will spend the final two weeks parallelizing it. As such, we are leaving the kinect off for now as more of a “reach goal” we will get to if we have time. Our primary goal for now is making our algorithm run in parallel. Because of this, our new schedule looks something like this:\r\n\r\nWeek 2.5 (By Nov 22): Meet with TAs/professors to fully understand algorithm and link 3rd party libraries (armadillo?,openGL?,cuda?)\r\n- We will both meet with Keenan to discuss algorithm\r\n- Both meet with TAs or graphics on how to get openGL/Armadillo to compile\r\n\r\nWeek 3 (By Nov 28) have serial implementation working and start parallelization\r\n- Adit focuses on planes and nearest neighbors and distance function\r\n- Jordan focuses on cubes and mesh refinement\r\n- Both focus on propagating normal vectors since requires parallelizing an MST\r\n\r\nWeek 3.5 (By Dec 1): Rough parallelism of each step\r\n- Same assignments\r\n\r\nWeek 4 (By Dec 5): identify bottlenecks and attempt possible fixes\r\n- Meeting up and doing this together\r\n\r\nWeek 5 (By Dec 13): Gather data for various meshes; try some tricks to address bottlenecks\r\n- Too soon to tell who does what\r\n\r\n### How we're doing\r\nThus far we have generated point clouds for different shapes (sphere, cubes, etc) for testing. We can view these using Blender. We are following Hugues Hoppe’s thesis on Surface Reconstruction from Unorganized Points to produce a serial algorithm. The majority of this algorithm has been coded, but we are currently in the process of debugging. Although we are still working on the serial implementation, we have discussed how to parallelize sections of the algorithm. For example, for step 3 of the algorithm, we plan on creating a quad-tree to group the points by location and then send that data to a core of the GPU. For step 4, we need to propagate consistent normal vectors between neighboring planes via a Minimum Spanning Tree. Processing the different layers of this tree in parallel will be an interesting task; we were thinking of processing the tree in BFS so that after every few iterations we can somehow ‘fork off’ work since the nodes are independent of each other (since it’s a tree). One final interesting aspect of parallelization is that currently neighbors are doing redundant work (since all cubes share faces with their neighbors); deciding how much or how little we want the neighbors to communicate to each other will have to be determined through experimentation.\r\nOne last thing to note is that the nice thing about using voxels in a 3D space is we can fully take advantage of CUDAs 3D indexing since cube(i,j,k) could be mapped to thread.ijk!\r\n\r\n\r\nWe will be able to produce most of the deliverables except for the final task of creating our own point clouds using the Microsoft Kinect. Doing this would be a reach-goal that we would attempt once our parallel implementation is mostly complete. Currently, however, we are behind on implementing the original surface reconstruction algorithm.\r\nGoal 1: Produce a dense surface reconstruction of a point cloud.\r\nGoal 2: Refine mesh to reduce number of edges while keeping the shape intact.\r\nGoal 3 (Reach Goal): Create our own point clouds using a Kinect and test our own algorithm on it.\r\n\r\n### Algorithm\r\nOur algorithm has roughly nine steps:\r\n\r\n1. Read points from input file\r\n2. Find nearest neighbors for every point\r\n3. Create tangent planes for each point based on its nearest neighbors (approximate surface)\r\n4. Propagate the normal direction between neighboring planes so that they’re all roughly pointing the same direction\r\n5. Be able to call a distance function that tells us approximate distance to surface from any arbitrary point in  space\r\n6. Turn the 3D space encompassing our point cloud into a bunch of cubes/voxels (either implicitly or explicitly)\r\n7. Create the approximate mesh based on what distance values are calculated for the corners of the cubes\r\n8. Refine the mesh (likely to be very dense since a point cloud) by deleting unnecessary vertices and trying to have every vertex degree roughly the same\r\n9. Write mesh to an output file\r\n\r\nCurrently, we’ve serially implemented 1-3,5-7 and 9. We have a rough plan of how we plan to parallelize each stage but we must first debug our serial implementation.\r\n\r\nBug: Difficulty has arisen for step 3 because we were hoping to use the Armadillo C++ library to do PCA for us for finding the normals; we can’t seem to understand how to link this library to our code so instead we found code online that calculates the eigenvalues of a 3x3 matrix and are trying to interface with it from our code.\r\nThe benefit of our code is that it is very modular (clearly defined steps). To test our code, we can do the following:\r\n\r\n1. Generate and output planes to see if they look correct.\r\n2. Generate a new point cloud everywhere our distance function is negative (implies inside our mesh) to see if this function is correct.\r\n3. Output our final mesh to see if it looks like our point cloud.\r\n\r\nWe have left our serial implementation very basic so that we can focus our time on parallelizing it:\r\nNearest neighbor search: just loop through all points, calculate distance, and keep the closest.\r\nCreate tangent planes: get nearest neighbors for each point, approximate centroid and normal.\r\nDistance function: First find nearest point, then get distance to that plane\r\n\r\nTurning 3D space into voxels: First we get bounding box for all points, then we divide it into cubes (our bounding box struct)\r\n\r\nCreating mesh: for each cube, evaluate the distance function at its corners. No communication between neighbors. We want mesh to be where distance function is zero, so we interpolate values between corners that are positive and corners that are negative to approximate mesh.\r\n\r\nWriting mesh to file: Since our cubes don’t communicate to their neighbors at all, this means they generate redundant vertices. Thus, we must sort the vertices and delete duplicates and then also have our edge array index into the vertex array to follow .obj format.\r\n\r\nWe currently have NOT implemented steps 4 and 8. Step 4 requires us to create an MST/MSF of our points so that nearby points have normal vectors pointing in the same direction; we didn’t want to implement this until we had working normal vectors. Similarly step 8 refines our mesh so we can’t implement this until we have our mesh working. Jordan has taken 15-462 before and one of his homeworks involved mesh simplification, so he is confident this step will be simple once we have the full mesh generated.\r\n\r\n\r\n### Poster Session\r\nOur project is creating a mesh from a point cloud, so in a perfect scenario our demo will include a bunch of examples of this happening! This will mean displaying images of the original point cloud, our reconstructed mesh, and performance graphs. Potentially, as a reach goal, we would have the mesh graphically generated live as a demo to visualize how the points connect.\r\n\r\n### Preliminary Results\r\nWe have written a rough serial version of our program and have plans on how to parallelize it. Currently we are in the debugging stage because we were not able to link the C Armadillo API to our code (which means we had to grab some stranger’s code (which we have cited) off the internet and are now trying to understand it so we can call it from our code. The code is for PCA analysis of a matrix, which is needed for generating normals in the point cloud.\r\n\r\nBecause we are in the debug stage, we do not yet have results to show but we should by the end of the week!\r\n\r\n\r\n### Current Issues\r\nWe have a few issues currently. Some of the methods discussed in Hoppe’s paper are vague and research into them have not been too fruitful. We plan on discussing these issues with a Computer Graphics/Vision professor to see if he might be able to shed some light. More pressing, however, include learning to write Makefiles and using an API. We would like to use Armadillo, a C++ linear algebra library, for computing the tangent planes at each point (Step 2). This would allow us to implement the initial serial algorithm quicker and allow us to avoid the hassle of writing new matrix data structures.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}